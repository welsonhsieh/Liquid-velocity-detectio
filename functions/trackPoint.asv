function positions = trackPoint(frames, ~, startFrame)
    positions = nan(numFrames,2);
    positions(startFrame,:) = refPoint;
    prevPos = positions(startFrame,:);
    fprintf('trackPoint init: startFrame=%d refPoint=[%.1f,%.1f] frameSize=[%d,%d]\n', ...
    startFrame, prevPos(1), prevPos(2), size(frames{startFrame},1), size(frames{startFrame},2));

    % ROI + 最近 blob + 排除貼底 的前緣偵測追蹤器
    numFrames = length(frames);
    positions = nan(numFrames, 2);

    % 參數（可調）
    roiRadius = 120;           % ROI 半徑（像素）
    minArea = 200;             % 最小 blob 面積（像素）
    maxArea = 1e6;             % 最大 blob 面積（像素）
    maxJump = 80;              % 最大允許跳躍距離（像素）
    bottomMargin = 5;          % 若 bbox 底邊距離影像底部 <= bottomMargin 則視為貼底（排除）
    useDebug = false;          % 若要看候選 bbox，設 true

    prevPos = [];
    for i = startFrame:numFrames
        frame = frames{i};
        gray = rgb2gray(frame);
        gray = imadjust(gray); % 增強對比
        bw = imbinarize(gray, 'adaptive');
        bw = bwareaopen(bw, 50); % 去小雜點

        cc = bwconncomp(bw);
        if cc.NumObjects == 0
            positions(i,:) = prevPos; % 無候選時保留上一位置
            continue;
        end

        stats = regionprops(cc, 'Area', 'BoundingBox', 'Centroid');
        imgH = size(gray,1);
        imgW = size(gray,2);

        % 篩選合法候選（面積與非貼底）
        validIdx = [];
        for k = 1:length(stats)
            a = stats(k).Area;
            bbox = stats(k).BoundingBox; % [x y w h]
            bottomY = bbox(2) + bbox(4);
            if a >= minArea && a <= maxArea && (imgH - bottomY) > bottomMargin
                validIdx(end+1) = k; %#ok<AGROW>
            end
        end

        if isempty(validIdx)
            % 若全部被排除，放寬條件：只排除極小面積
            for k = 1:length(stats)
                if stats(k).Area >= minArea/4
                    validIdx(end+1) = k; %#ok<AGROW>
                end
            end
        end

        if isempty(validIdx)
            positions(i,:) = prevPos;
            continue;
        end

        % 若有 prevPos，先在 ROI 內找候選
        chosenIdx = [];
        if ~isempty(prevPos) && ~any(isnan(prevPos))
            x0 = prevPos(1); y0 = prevPos(2);
            roiCandidates = [];
            for idx = validIdx
                c = stats(idx).Centroid;
                if hypot(c(1)-x0, c(2)-y0) <= roiRadius
                    roiCandidates(end+1) = idx; %#ok<AGROW>
                end
            end
            if ~isempty(roiCandidates)
                % 從 ROI 候選中選距離最近者
                cents = cat(1, stats(roiCandidates).Centroid);
                dists = hypot(cents(:,1)-x0, cents(:,2)-y0);
                [~,m] = min(dists);
                chosenIdx = roiCandidates(m);
            end
        end

        % 若 ROI 沒找到，從全域 validIdx 選最近者（或最大面積）
        if isempty(chosenIdx)
            centsAll = cat(1, stats(validIdx).Centroid);
            if ~isempty(prevPos) && ~any(isnan(prevPos))
                distsAll = hypot(centsAll(:,1)-prevPos(1), centsAll(:,2)-prevPos(2));
                [~,m2] = min(distsAll);
                chosenIdx = validIdx(m2);
            else
                % 第一幀或無 prevPos：選最大面積
                areas = arrayfun(@(s) s.Area, stats(validIdx));
                [~,m3] = max(areas);
                chosenIdx = validIdx(m3);
            end
        end

        % 從 chosenIdx 取前緣（底邊中點）
        bbox = stats(chosenIdx).BoundingBox;
        frontX = bbox(1) + bbox(3)/2;
        frontY = bbox(2) + bbox(4);

        % 檢查跳躍距離，若超過 maxJump，保留 prevPos（避免跳到錯誤 blob）
        if ~isempty(prevPos) && ~any(isnan(prevPos))
            if hypot(frontX-prevPos(1), frontY-prevPos(2)) > maxJump
                % 若有其他 validIdx 距離 prevPos 更近，嘗試選它
                centsAll = cat(1, stats(validIdx).Centroid);
                distsAll = hypot(centsAll(:,1)-prevPos(1), centsAll(:,2)-prevPos(2));
                [minD, minIdx] = min(distsAll);
                if minD <= maxJump
                    chosenIdx = validIdx(minIdx);
                    bbox = stats(chosenIdx).BoundingBox;
                    frontX = bbox(1) + bbox(3)/2;
                    frontY = bbox(2) + bbox(4);
                else
                    % 否則保留 prevPos
                    positions(i,:) = prevPos;
                    continue;
                end
            end
        end

        positions(i,:) = [frontX, frontY];
        fprintf('Frame %d: chosenPos=[%.1f,%.1f] prevPos=[%.1f,%.1f]\n', ...
        i, positions(i,1), positions(i,2), prevPos(1), prevPos(2));

        prevPos = positions(i,:);

        % debug 視覺化（可選）
        if useDebug
            imshow(frame); hold on;
            for k = validIdx
                rectangle('Position', stats(k).BoundingBox, 'EdgeColor','y');
            end
            rectangle('Position', bbox, 'EdgeColor','r', 'LineWidth',2);
            plot(prevPos(1), prevPos(2), 'ro', 'MarkerFaceColor','r');
            hold off; drawnow;
            pause(0.05);
        end
    end
end