function positions = trackPoint(frames, refPoint, startFrame, roi)
% trackPoint 追蹤流體前緣（邊緣優先 + ROI + blob fallback）
% frames: cell array of RGB frames
% refPoint: [x,y] 起始參考點（像素座標）
% startFrame: 起始幀索引
% roi: optional [x y w h] 限制搜尋區域
%
% 返回 positions: numFrames x 2

    % --- 基本檢查與初始化 ---
    if nargin < 1 || isempty(frames)
        error('frames 必須為 cell array of images');
    end
    numFrames = numel(frames);
    positions = nan(numFrames,2);
    if nargin < 4, roi = []; end
    if nargin < 3 || isempty(startFrame), startFrame = 1; end
    startFrame = max(1, min(startFrame, numFrames));

    % 驗證 refPoint
    if nargin < 2 || isempty(refPoint) || any(isnan(refPoint))
        fsize = size(frames{startFrame});
        refPoint = [round(fsize(2)/2), round(fsize(1)/2)];
        warning('trackPoint: refPoint 無效，改用影像中心 [%d,%d]', refPoint(1), refPoint(2));
    end

    positions(startFrame,:) = refPoint;
    prevPos = refPoint;
    prevPrevPos = [];

    % --- 參數（可調） ---
    roiRadius = 200;    % ROI 搜尋半徑（像素）
    minArea = 80;       % blob 最小面積
    maxJump = 150;      % 每幀最大允許移動距離
    bwarea_min = 50;    % 二值化後去小雜點
    edgeMinArea = 10;   % 邊緣點最小群組面積（bwareaopen）
    useEdgeFirst = true; % 優先使用邊緣偵測
    useDebug = false;    % 若要視覺化，設 true

    % --- 主迴圈 ---
    for i = startFrame+1:numFrames
        frame = frames{i};
        if isempty(frame)
            positions(i,:) = prevPos;
            continue;
        end

        gray = rgb2gray(frame);
        gray = imadjust(gray);

        % 若有 ROI，先裁切子影像（但回傳座標仍為原座標系）
        if ~isempty(roi)
            x = round(roi(1)); y = round(roi(2)); w = round(roi(3)); h = round(roi(4));
            x1 = max(1,x); y1 = max(1,y);
            x2 = min(size(gray,2), x + max(0,w)); y2 = min(size(gray,1), y + max(0,h));
            sub = gray(y1:y2, x1:x2);
        else
            sub = gray;
            x1 = 1; y1 = 1; % 用於回算座標
        end

        chosen = []; chosenType = '';

        % --- 方法 A: 邊緣偵測（優先） ---
        if useEdgeFirst
            % --- local-edge 搜尋（以 prevPos 為中心的窄欄搜尋） ---
            halfWidth = 40;        % 可調，左右搜尋寬度（像素）
            areaThresh = 10;       % bwareaopen 閾值
            
            % 呼叫 local edge finder，傳入 prevPos（global coords），x1 為子影像左上角 x
            [fx_local, fy_local, okEdgeLocal] = detectFrontEdgeLocal(sub, prevPos, x1-1, halfWidth, areaThresh);
            
            if okEdgeLocal
                % detectFrontEdgeLocal 回傳的是 global x 與 sub-row y (若 caller 用 y1 offset 則需加上)
                % 我們在 detectFrontEdgeLocal 已回傳 global x (加上 xOffset)，但 y 仍為 sub row，
                % 因此回算到 global y：
                fy_global = fy_local + y1 - 1;
                fx_global = fx_local; % 已為 global x
                cand = limitMove(prevPos, [fx_global, fy_global], maxJump);
                positions(i,:) = cand;
                prevPrevPos = prevPos;
                prevPos = positions(i,:);
                if useDebug
                    fprintf('Frame %d: edgeLocal chosen=[%.1f,%.1f]\n', i, cand(1), cand(2));
                end
                continue;
            end
            % 若 okEdgeLocal 為 false，會 fallback 到 blob-based 程式段（下方）

        end

        % --- 方法 B: blob-based fallback ---
        % 二值化（在整張或 ROI 子影像上）
        if ~isempty(roi)
            bwAll = imbinarize(sub, 'adaptive');
            bw = bwareaopen(bwAll, bwarea_min);
            % 將 bw 放回原大小的 mask（方便 regionprops 若需要）
            maskFull = false(size(gray));
            maskFull(y1:y2, x1:x2) = bw;
            bwFull = maskFull;
        else
            bwFull = imbinarize(gray, 'adaptive');
            bwFull = bwareaopen(bwFull, bwarea_min);
        end

        cc = bwconncomp(bwFull);
        if cc.NumObjects == 0
            % 若沒有 blob，保留 prevPos
            positions(i,:) = prevPos;
            if useDebug, fprintf('Frame %d: no blobs -> keep prev\n', i); end
            continue;
        end

        stats = regionprops(cc, 'Area', 'BoundingBox', 'Centroid');
        imgH = size(gray,1);

        % 篩選 validIdx（面積與非貼底）
        validIdx = [];
        for k = 1:length(stats)
            a = stats(k).Area;
            bbox = stats(k).BoundingBox;
            bottomY = bbox(2) + bbox(4);
            if a >= minArea && (imgH - bottomY) > 5
                validIdx(end+1) = k; %#ok<AGROW>
            end
        end
        if isempty(validIdx)
            % 放寬條件
            for k = 1:length(stats)
                if stats(k).Area >= minArea/4
                    validIdx(end+1) = k; %#ok<AGROW>
                end
            end
        end
        if isempty(validIdx)
            positions(i,:) = prevPos;
            if useDebug, fprintf('Frame %d: no valid blobs -> keep prev\n', i); end
            continue;
        end

        % 預測 predPos（線性外推）
        if ~isempty(prevPrevPos)
            predPos = prevPos + (prevPos - prevPrevPos);
        else
            predPos = prevPos;
        end

        % 以 predPos 為中心在 validIdx 中找 roiCandidates
        x0 = predPos(1); y0 = predPos(2);
        roiCandidates = [];
        for idx = validIdx
            c = stats(idx).Centroid;
            if hypot(c(1)-x0, c(2)-y0) <= roiRadius
                roiCandidates(end+1) = idx; %#ok<AGROW>
            end
        end

        if ~isempty(roiCandidates)
            cents = cat(1, stats(roiCandidates).Centroid);
            dists = hypot(cents(:,1)-x0, cents(:,2)-y0);
            [~, m] = min(dists);
            chosenIdx = roiCandidates(m);
        else
            centsAll = cat(1, stats(validIdx).Centroid);
            distsAll = hypot(centsAll(:,1)-prevPos(1), centsAll(:,2)-prevPos(2));
            [~, m2] = min(distsAll);
            chosenIdx = validIdx(m2);
        end

        bbox = stats(chosenIdx).BoundingBox;
        candX = bbox(1) + bbox(3)/2;
        candY = bbox(2) + bbox(4);

        % 若距離過大，限制每幀最大位移
        positions(i,:) = limitMove(prevPos, [candX, candY], maxJump);
        prevPrevPos = prevPos;
        prevPos = positions(i,:);
        chosen = positions(i,:);
        chosenType = 'blob';
        if useDebug
            fprintf('Frame %d: blob chosen=[%.1f,%.1f]\n', i, chosen(1), chosen(2));
        end
    end
end

% 在每幀處理前（若有 ROI），計算 x1,y1 如你現有程式
% 假設 sub = gray(y1:y2, x1:x2) 已建立（或 sub = gray 並 x1=1）

halfWidth = 40;        % 可調，左右搜尋寬度（像素）
areaThresh = 10;       % bwareaopen 閾值

% 呼叫 local edge finder，傳入 prevPos（global coords）
[fx, fy, okEdge] = detectFrontEdgeLocal(sub, prevPos, x1-1, halfWidth, areaThresh);

if okEdge
    % 若 fy 是 sub 的 row，已在 helper 回傳為 sub row；若 ROI 有 y1 offset，helper 回傳已是 global y
    % 若距離 prevPos 太遠，限制移動
    newPos = limitMove(prevPos, [fx fy], maxJump);
    positions(i,:) = newPos;
    prevPrevPos = prevPos;
    prevPos = newPos;
    continue;
end
% 若 okEdge false，fallback 到 blob-based 方法（你現有程式）


% ---------------- helper: limitMove ----------------
function p = limitMove(prev, cand, maxStep)
    if isempty(prev) || any(isnan(prev))
        p = cand;
        return;
    end
    dx = cand(1) - prev(1);
    dy = cand(2) - prev(2);
    d = hypot(dx, dy);
    if d <= maxStep || d == 0
        p = cand;
    else
        s = maxStep / d;
        p = [prev(1) + dx * s, prev(2) + dy * s];
    end
end
% --- 新增 helper: detectFrontEdgeLocal ---
% subGray: 灰階子影像（若有 ROI，為 ROI 子影像；否則為整張）
% prevPosLocal: [x,y] in global coords (will be converted to sub coords by caller)
% xOffset: x1-1 (global->sub offset)
% halfWidth: 搜尋欄位半寬（像素）
% areaThresh: bwareaopen 閾值
function [frontX_global, frontY_global, ok] = detectFrontEdgeLocal(subGray, prevPosLocal, xOffset, halfWidth, areaThresh)
    ok = false; frontX_global = NaN; frontY_global = NaN;
    if isempty(subGray), return; end

    % 1) Canny + small morphology to connect edges
    edges = edge(subGray, 'Canny');
    edges = imclose(edges, strel('line',5,0));    % connect near-horizontal gaps
    edges = bwareaopen(edges, max(1, areaThresh));

    % 2) convert prevPos to sub coords
    prevX_sub = prevPosLocal(1) - xOffset;
    prevY_sub = prevPosLocal(2); % y offset already handled by cropping caller

    % clamp prevX_sub
    prevX_sub = round(max(1, min(size(subGray,2), prevX_sub)));

    % 3) define column window
    xL = max(1, round(prevX_sub - halfWidth));
    xR = min(size(subGray,2), round(prevX_sub + halfWidth));

    % 4) search downward in each column for edge pixels, collect candidates
    [er, ec] = find(edges(:, xL:xR)); % er, ec relative to xL
    if isempty(er)
        % fallback: use global most-bottom edge if exists
        [er_all, ec_all] = find(edges);
        if isempty(er_all), return; end
        frontY_sub = max(er_all);
        xs = ec_all(er_all == frontY_sub);
        frontX_sub = mean(xs);
    else
        % convert ec to absolute sub coords
        ec_abs = ec + xL - 1;
        % pick candidate with largest y (max er), tie-break by minimal |x - prevX_sub|
        maxY = max(er);
        idxs = find(er == maxY);
        xs_at_maxY = ec_abs(idxs);
        % choose one closest in x to prevX_sub
        [~, idxMin] = min(abs(xs_at_maxY - prevX_sub));
        frontX_sub = xs_at_maxY(idxMin);
        frontY_sub = maxY;
    end

    % 5) convert back to global coords
    frontX_global = frontX_sub + xOffset;
    frontY_global = frontY_sub; % caller must add y offset if cropping used
    ok = true;
end
